{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"UA-6774000-3","body":"**Important note: Galry is still an experimental project with an unstable\r\nprogramming interface that is likely to change at any time. Do not use it in\r\nproduction yet.**\r\n\r\nWhat is Galry?\r\n--------------\r\n\r\nGalry is a **high performance interactive 2D visualization package in \r\nPython**. It lets you visualize and navigate into very large 2D plots (signals,\r\npoints, textures...) in real time, by using the graphics card as much as\r\npossible (with OpenGL).\r\nOn a 2012 computer with a recent 250$ graphics card, one can interactively\r\nvisualize as much as **100 million points** at a reasonable framerate.\r\n\r\nGalry is not meant to generate high-quality plots (like matplotlib), and is\r\nmore \"low-level\". It can be used to write complex interactive visualization\r\nGUIs that deal with large 2D datasets (only with QT for now).\r\n\r\nIt is based on PyOpenGL and Numpy and is\r\nmeant to work on any platform (Window/Linux/MacOS).\r\nMandatory dependencies include Python 2.7, Numpy, either PyQt4 or PySide,\r\nPyOpenGL, matplotlib.\r\n\r\nOptional dependencies include IPython, hdf5, PyOpenCL (the last two are not\r\ncurrently used but may be in the future).\r\n\r\n\r\nI want to see a demo!\r\n---------------------\r\n\r\n[![Galry's Demo](https://raw.github.com/rossant/galry/master/images/youtube.png)](http://www.youtube.com/watch?v=jYNJJ4O3pXo)\r\n\r\n![Galry's gallery](https://raw.github.com/rossant/galry/master/images/overview.png)\r\n\r\n\r\nWhy Galry?\r\n----------\r\n\r\nMost visualization packages in Python are either meant to generate high-quality\r\npublication-ready figures (like matplotlib), or to offer 3D fast interactive \r\nvisualization (like mayavi).\r\nExisting 2D plotting packages do not generally offer an efficient way to \r\ninteractively visualize large datasets (1, 10, even 100 million points). \r\nThe main goal of Galry is to provide the most optimized way of visualizing\r\nlarge 2D datasets, by using the full power of the graphics card.\r\n\r\n\r\nHow fast is it?\r\n---------------\r\n\r\nPerformance and speed are the major objectives of Galry. The Python overhead\r\nis minimized so that performance is only limited by the power of the\r\ngraphics card. We can approximately assess the performance of Galry by\r\nmeasuring the number of frames per second (FPS) when navigating in a scene\r\ncontaining a large number of points.\r\n\r\nHere are some results with a basic benchmark consisting of an N points plot\r\n(`benchmarks/benchmark01_points.py`). \r\n*More systematic and automatic benchmark methods will be considered in the \r\nnear future.*\r\n\r\nOn a 2012 desktop computer with a high-end AMD Radeon HD 7870 graphics card:\r\n\r\n  * N = 10 million points: ~125 FPS\r\n  * N = 20 million points: ~80 FPS\r\n  * N = 50 million points: ~35 FPS\r\n  * N = 100 million points: ~15 FPS\r\n\r\nThe [benchmark page](https://github.com/rossant/galry/wiki/Benchmarks) contains \r\nmore details. Users are invited to do their own benchmark.\r\n\r\n\r\nWhat can I do with Galry?\r\n-------------------------\r\n\r\nYou can either:\r\n\r\n  * Visualize large 2D datasets consisting of points, lines or textures,\r\n    and pan/zoom smoothly into your data.\r\n    \r\n  * Create your own customized GUI designed for highly efficient specialized\r\n    interactive visualization of large 2D datasets.\r\n    \r\nGalry is fully customizable, and you can either write a specialized scientific\r\nvisualization GUI, a particle system, a fractal viewer, or even a video\r\ngame!\r\n\r\n### Custom visualization\r\n\r\nThe library gives you full control on the rendering pipeline process, through\r\nthe use of vertex and fragment shaders. Shaders are small programs written in\r\na simple C-like low-level language ([GLSL](http://en.wikipedia.org/wiki/GLSL)) \r\nthat are dynamically compiled on the GPU.\r\nThey transform the raw data stored in GPU memory to pixels on the screen.\r\nLearning and using GLSL lets you exploit the full power of the GPU for\r\nthe most optimized possible way of rendering data.\r\n\r\nHelper functions are also included for common tasks such as displaying\r\nlines, points, polygons, textures, sprites, and text.\r\n\r\n### Custom interactivity\r\n\r\nThe library gives you full control on the interaction system.\r\n*User actions* such as mouse clicks, mouse mouvements, keystrokes, etc., \r\ncan be linked to arbitrary *interaction events* such as panning, zooming, etc.\r\nYou can define new interaction events and decide how exactly they interfere\r\nwith rendering. Possible uses include selection of objects, layout\r\nmodifications, etc.\r\n\r\n### Integration in QT\r\n\r\nGalry provides a QT widget written in Python displaying an OpenGL rendering\r\nviewport. This widget contains your data. It can also interact with other\r\nQT widgets within a single application, in particular through the use of \r\nQT signals and slots. These are the normal way QT widgets talk to each other,\r\nand they allow the development of a full visualization GUI with one or\r\nseveral Galry widgets. The Galry interaction system can be easily linked\r\nto the QT interaction system based on signals and slots.\r\n\r\nIntegration with other GUI systems like TKinter or wx, might be considered\r\nas some point. The only constraint is that this system provides an OpenGL\r\ncontext.\r\n\r\n\r\nHow does it work?\r\n-----------------\r\n\r\nGalry is written directly on top of PyOpenGL, a Python wrapper to OpenGL.\r\nOpenGL is a widely used hardware-accelerated open library implemented in\r\nvirtually every graphics card. As of today, it is probably the most efficient\r\nportable low-level library for interactive rendering.\r\n\r\nWhereas OpenGL provides a low-level API for rendering, Galry offers a\r\nplotting-oriented interface, allowing to render points, lines, textures,\r\nsprites and text. However, you can also use lower-level functions that\r\ngive you full control about the data you put on GPU memory, and how this data \r\nis transformed into pixels through vertex and fragment shaders.\r\n\r\n\r\nHow to get started?\r\n-------------------\r\n\r\nAt the time of writing, the code is still quite experimental and is not\r\nguaranteed to work on any platform. The programming interface is still\r\nunstable and might change without any further notice. Installation may be\r\ndifficult depending on the OS and the graphics card drivers. But feel\r\nfree to experiment with it or to take a look to the documentation.\r\n\r\nThe `master` branch contains the latest \"stable\" version, whereas the\r\ndevelopment version is in the `dev` branch.\r\n\r\nThe [installation page](https://github.com/rossant/galry/wiki/Installation)\r\nalso contains details on how to install Galry. \r\n\r\nThere are several sources of documentation, all available in the `docs` folder.\r\nExamples and tutorials are in separated folders.\r\n\r\n  * The user guide: a high-level overview of the library. It's a good starting \r\n    point if you prefer a top-down approach.\r\n    \r\n  * The tutorials: hands-on tutorials to start galrying now. They're a good\r\n    starting point if you prefer a bottom-up approach. They contain more \r\n    technical details than the user guide. It is recommanded that you go\r\n    through both the user guide and the tutorials anyway.\r\n\r\n  * The examples: they cover a wide range of Galry's possibilities.\r\n    \r\n  * The API reference: once you know the fundamentals, use the reference\r\n    if you want to go deeper into Galry.\r\n    \r\n    \r\nHow did this project start?\r\n---------------------------\r\n\r\nWe created this project as part of the development of a specific\r\nelectrophysiological data GUI that will handle very large datasets.\r\n\r\n\r\nI want to participate!\r\n----------------------\r\n\r\n[Send me an e-mail](http://cyrille.rossant.net).\r\n\r\n\r\nWhy this name?\r\n--------------\r\n\r\nDon't even ask.\r\n\r\n","name":"Galry","tagline":"High-performance interactive 2D visualization in Python"}